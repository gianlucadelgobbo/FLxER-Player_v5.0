package {	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;	import flash.events.*;	import flash.utils.*;	import flash.net.*;	import flash.net.SharedObject;	//	import FLxER.core.FlxerInterface;	import FLxER.core.Monitor;	import FLxER.Preloader;	import FLxER.panels.Options;	import FLxER.panels.Mess;	import FLxER.comp.Alt;	public class FlxerStarter extends Sprite {		public var monitor;		//		var c;		var receiving_lc;		var startDelay;		var myOptions, myOptions2, myAlert;		public var myAlt;		public function FlxerStarter() {			startDelay = 500;			Preferences.createPref(stage.stageWidth,stage.stageHeight)			splash = new Preloader(40338);			this.addChild(splash);			myPrefSO = SharedObject.getLocal("flxerPref","/",false);			if (myPrefSO.data.flxerPref == undefined || myPrefSO.data.flxerPref.childNodes[0].childNodes[4] == undefined) {				loadPref();			} else {				// 4 TO 5 flxerPref = flxerPref;				Preferences.pref.flxerPref = new XMLDocument(myPrefSO.data.flxerPref);				Preferences.updateCol();				c = setInterval(openOptions, 500);			}			//_root.myTabIndex = 1;		}		function loadPref() {			myLoader = new URLLoader(new URLRequest("preferences/flxerPref.xml"));			myLoader.addEventListener("complete", firstStartup);			myLoader.addEventListener("ioError", xmlNotLoaded);		}		function firstStartup(event) {			Preferences.pref.flxerPref = new XMLDocument(parseXML(myLoader.data));			Preferences.pref.flxerPref.ignoreWhite = true;			//flxerPref = tmpXml;			var tmp = new XML(Preferences.pref.flxerPref.childNodes[0]);			myPrefSO.data.flxerPref = tmp;			myPrefSO.flush();			Preferences.updateCol();			c = setInterval(openOptions, 500);		}		function openOptions() {			if (getTimer() > startDelay) {				clearInterval(c);				this.removeChildAt(0);				myOptions = new Options(400, 300, "FLXER STARTUP MODES",setMode);				this.addChild(myOptions);			}		}		public function setMode(n) {			Preferences.pref.myMode = n;			switch (n) {				case 0 :					loadPlugin();					break;				case 1 :					if (!receiving_lc) {						receiving_lc = new LocalConnection();						receiving_lc.client = this;						receiving_lc.connect("lc_mon");					}					//receiving_lc["trgt"] = this;					c = setInterval(checkMonOut, 2000);					this.myOptions.visible = false;						var sending_lc = new LocalConnection();					sending_lc.send("lc_flxer", "getMonitor");							break;				case 2 :					this.myFlxerSSConnectorSender = new FLxER.core.FlxerSSConnector(this, "SSConnectorOk");					myOptions2 = new FLxER.panels.OptionsRemoteReceiver({w:400, h:300, tit:"REMOTE RECEIVER MODE OPTIONS", txt:"1) CONNECT TO A FLASH MEDIA SERVER APPLICATION (rtmp url)", trgt:this.myFlxerSSConnectorSender});					this.addChild(myOptions2);					break;			}/**/		}		public function setMonitor(obj) {			//this.trgt.removeChildAt(0);			trace("bella2")			Preferences.pref.monXscale = obj.monXscale			Preferences.pref.monYscale = obj.monYscale			Preferences.pref.dScaleX = obj.dScaleX;			Preferences.pref.dScaleY = obj.dScaleY;			clearInterval(c);			loadPlugin();		};		function SSConnectorOk(ww,hh) {			trace("ww "+ ww)			trace("hh "+ hh)						_global.monXscale = (ww/400)*100;			_global.monYscale = (hh/300)*100;			if(ww/hh>4/3){				_global.dScaleX = _global.monYscale/_global.monXscale;				_global.dScaleY = 1;			} else {				_global.dScaleX = 1;				_global.dScaleY = _global.monXscale/_global.monYscale;			}			loadPlugin()		}		function checkMonOut() {			this.myOptions.visible = true;			clearInterval(c);			myAlert = new Mess(200, 100, "ALERT", "Before to start you have to run the application named:\n\n- FLxER4monitorOut\n\n");			this.addChild(myAlert);		}		function xmlNotLoaded(event:Event):void {			trace("Data not loaded."+event);		}		public function loadPlugin() {			myLoader = new URLLoader(new URLRequest("preferences/plugIn.xml"));			myLoader.addEventListener("complete", loadSeqPattern);			myLoader.addEventListener("ioError", xmlNotLoaded);		}		public function loadSeqPattern(event) {			Preferences.pref.plugin = new XMLDocument();			Preferences.pref.plugin.ignoreWhite = true;			Preferences.pref.plugin.parseXML(myLoader.data);			myLoader = new URLLoader(new URLRequest("preferences/plugIn.xml"));			myLoader.addEventListener("complete", loadLib);			myLoader.addEventListener("ioError", xmlNotLoaded);		}		public function loadLib(event) {			Preferences.pref.sequencerPattern = new XMLDocument();			Preferences.pref.sequencerPattern.ignoreWhite = true;			Preferences.pref.sequencerPattern.parseXML(myLoader.data);			myLoader = new URLLoader(new URLRequest("preferences/playlists.xml"));			myLoader.addEventListener("complete", startup);			myLoader.addEventListener("ioError", xmlNotLoaded);		}		public function startup(event) {			Preferences.pref.libraryList = new XMLDocument();			Preferences.pref.libraryList.ignoreWhite = true;			Preferences.pref.libraryList.parseXML(myLoader.data);			//			Preferences.pref.blendList = new XMLDocument();			Preferences.pref.blendList.ignoreWhite = true;			var list:XML = <lib><a m="normal" /><a m="layer" /><a m="multiply" /><a m="screen" /><a m="lighten" /><a m="darken" /><a m="difference" /><a m="add" /><a m="subtract" /><a m="invert" /><a m="alpha" /><a m="erase" /><a m="overlay" /><a m="hardlight" /></lib>;			Preferences.pref.blendList.parseXML(list);			Preferences.pref.plugin.childNodes[0].childNodes[0].insertBefore(Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].cloneNode(true),Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0]);			Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].attributes.m = "HORIZONTAL";			Preferences.pref.plugin.childNodes[0].childNodes[0].insertBefore(Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].cloneNode(true),Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0]);			Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].attributes.m = "VERTICAL";			Preferences.pref.plugin.childNodes[0].childNodes[0].insertBefore(Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].cloneNode(true),Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0]);			Preferences.pref.plugin.childNodes[0].childNodes[0].childNodes[0].attributes.m = "WIPE NONE (MIX)";				//if (System.capabilities.os.substring(0, 3) == "Win" || System.capabilities.os.substring(0, 3) == "Mac") {			if (Preferences.pref.flxerPref.childNodes[0].childNodes[2].attributes.value == "true") {				Preferences.pref.vKS = true;			} else {				Preferences.pref.vKS = false;			}			Preferences.pref.nCh = parseInt(Preferences.pref.flxerPref.childNodes[0].childNodes[0].attributes.value.toString());			if (Preferences.pref.nCh < 1) {				Preferences.pref.nCh = 1;			} else if (Preferences.pref.nCh > 7) {				Preferences.pref.nCh = 7;			} else if (isNaN(Preferences.pref.nCh)) {				Preferences.pref.nCh = 7;			}			interfaceDrawer();		}		function interfaceDrawer() {			clearInterval(c);			this.removeChildAt(0);			//myTreDengine = new FLxER.treDengine();			//mykeyboard = new FLxER.keyboard();			trace("interfaceDrawer "+getTimer());			flxerInterface = new FlxerInterface();			this.addChild(flxerInterface);			monitor = new Monitor(200, 23, Preferences.pref.nCh, 1, "DRAG");			this.addChild(monitor);			this.myAlt  = new Alt();			this.addChild(myAlt);			Preferences.pref.myAlt = this.myAlt;		}		function resetta() {			myPrefSO.clear();			var tmp = new XML(flxerPref.childNodes[0]);			myPrefSO.data.flxerPref = tmp;			myPrefSO.flush();			/*for (var item in _root) {			if (_root[item]._x ! =  undefined) {			_root[item].removeMovieClip();			} else {			//delete _root[item]			}			}*/			interfaceDrawer();		}	}}